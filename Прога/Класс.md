C# является полноценным объектно-ориентированным языком. Это значит, что программу на C# можно представить в виде взаимосвязанных взаимодействующих между собой *объектов*.

Описанием объекта, его сущностью является **класс**, а **объект** представляет экземпляр этого класса.

Для лучшего понимания можно привести такую аналогию. У нас всех есть некоторое представление, шаблон о человеке: у человека есть имя, возраст, рост, цвет глаз и какие-то другие характеристики. А наше общее представление о человеке будет являться классом. Отдельно взятый человек может отличаться от других своими характеристиками, и этот конкретный человек будет являться объектом или экземпляром класса. 

Также важно понимать, что **класс** – это тип данных, то есть класс определяет как именно данные будут храниться в оперативной памяти, какие операции можно будет совершать с этими данными и т.п. А **объект класса** – это участок памяти, отформатированный в соответствии с этим типом данных.
## Объявление классов

Класс определяется с помощью ключевого слова `сlass`:
```cs
модификатор_доступа class название_класса
{
    // содержимое класса
}
```

Внутри класса находится его тело, в котором задаются данные и поведение. Поля, свойства, методы и события в классе собирательно называются _членами класса_.
## Создание и инициализация объектов

Объекты можно создать с помощью `new` ключевого слова, за которым следует имя класса, как показано ниже:
```cs
название_класса название_объекта = new название_класса();
```
Например:
```cs
public class Student
{
	public int Age;
	public string FirstName;
	public string LastName;
}
```

Напомню, что классы – это ссылочный тип, следовательно при создании объекта, создается лишь ссылка, которая никуда не ведет, поэтому при попытке обращения к этому объекту произойдет ошибка `NullReferenceException`. Чтобы избежать эту ошибку (это касается всех ссылочных типов), нужно инициализировать этот объект:
```cs
...
static Student[] students;
...

students = new Student[1];
students[0] = new Student();
students[0].FirstName = "John";
students[0].LastName = "Jones";
students[0].Age = 19;

students = new[]
		{
			new Student {LastName = "Jones", FirstName = "John"},
			new Student {LastName = "Williams", FirstName = "William"}
		};
```

## Поля и методы класса

Класс может хранить некоторые данные. Для хранения данных в классе применяются **поля.** По сути **поля класса** - это переменные, определенные на уровне класса. У каждого поля класса существует свой **модификатор доступа.**
Кроме того, класс может определять некоторое поведение или выполняемые действия. Для определения поведения в классе применяются **методы**.

```cs
class Person 
{
    public string Name = "Unnamed"; // у полей классов можно определить свое значение по умолчанию
    public int Age;
 
    public void Print()
    {
        Console.WriteLine($"Имя: {Name}  Возраст: {Age}");
    }
}
```

Для обращения к функциональности класса - полям, методам (а также другим элементам класса) применяется точечная нотация точки - после объекта класса ставится точка, а затем элемент класса:
```cs
объект.поле_класса
объект.метод_класса(параметры_метода)
```

```cs
Person person = new Person() { Name = "Semka-kulemka", Age = 20 };

// устанавливаем новое значение поля
person.Name = "Sementy";

// обращаемся к методу Print
person.Print();    // Имя: Sementy  Возраст: 20
```

## Статическое и динамическое

**Динамические** (не статические) данные – данные, связанные с объектом.
**Статические** данные – данные, связанные с классом. ^43ec76

Обращение к динамическим **полям** происходит через объект:
```cs
имя_объекта.имя_поля
```
А к статическим через класс:
```cs
имя_класса.имя_поля
```

К статическим и динамическим **методам** тоже относится [вышеописанное](Класс#^43ec76), однако нужно выделить некоторые особенности. 

**Динамический метод** - метод, вызываемый из объекта класса. В нем можно обращаться к динамическим полям данного объекта и статическим полям.
```cs
//пример динамического метода
class Student
{
	public string firstName;
	public string lastName;
	public int age;
	
	public void Print()
	{
		Console.WriteLine($"Имя:{firstName}, Фамилия:{lastName}, Возраст:{age}");
	}
}

static void Main()
{
	Student studentCSU = new Student() { firstName = "Simon", lastName = "Savilov", age = 20};
	studentCSU.Print();
}
```

**Статический метод** – метод, вызываемый из имени класса. В нем можно обращаться *только* к статическим полям объекта, к динамическим полям  можно обращаться только в том случае, если этот объект передается в метод как параметр.
```cs
//пример статического метода
class Student
{
	public string firstName;
	public string lastName;
	public int age;
	
	static public void Print(Student student)
	{
		Console.WriteLine($"Имя:{student.firstName}, Фамилия:{student.lastName}, Возраст:{student.age}");
	}
}

static void Main()
{
	Student studentCSU = new Student() { firstName = "Simon", lastName = "Savilov", age = 20};
	Print(studentCSU);
}
```

## Свойство класса. get и set.

**Setter (сеттер)** – метод, который позволяет *установить* значение для полей:
```cs
class Point
{
	private int x;
	
	public void SetX(int x)
	{
		this.x = x;
	}
}
```

**Getter (геттер)** – метод, который позволяет *получить* значение для полей:
```cs
class Point
{
	private int x;
	
	public void GetX()
	{
		return x;
	}
}
```

Кроме обычных методов в языке C# предусмотрены специальные методы доступа, которые называют **свойства**. Они обеспечивают простой доступ к полям классов, позволяют узнать их значение или выполнить их установку. **Свойства** играют ключевую роль в реализации инкапсуляции, поскольку они предоставляют контролируемый интерфейс к данным объекта. Это позволяет разработчикам изменять внутреннюю реализацию без воздействия на код, который использует объект.
#### Объявление свойства
```cs
[модификаторы] тип_свойства Имя_свойства
{
    get { действия, выполняемые при получении значения свойства}
    set { действия, выполняемые при установке значения свойства}
}
```

Вначале определения свойства могут идти различные модификаторы, в частности, модификаторы доступа. Затем указывается тип свойства, после которого идет название свойства (свойства в C# называют с заглавной буквы). Полное определение свойства содержит два блока с *методами доступа (аксессорами)* `get` и `set`.

В блоке `get` выполняются действия по получению значения свойства. В этом блоке с помощью оператора `return` возвращаем некоторое значение.

В блоке `set` устанавливается значение свойства. В этом блоке с помощью ключевого слова `value` мы можем получить значение, которое передано свойству.
```cs
class Point
{
	private int x;
	
	public int X
	{
		get { return x; }
		set { x = value; }
	}
}
```

Блоки `set` и `get` не обязательно одновременно должны присутствовать в свойстве. Если свойство определяет только блок `get`, то такое свойство доступно *только для чтения* - мы можем получить его значение, но не установить.

И, наоборот, если свойство имеет только блок `set`, тогда это свойство доступно *только для записи* - можно только установить значение, но нельзя получить. 

Например, здесь свойство Name доступно *только для чтения*, т.е. мы можем получить его значение, но **не можем установить**, поскольку оно имеет только блок `get`:
```cs
class Person
{
    private string name;
    
	public string Name
	{
	    get { return name; }
	}
}
public static void Main()
{
	var person = new Person();
	Console.WriteLine(person.Name);  // получить можно
	person.Name = "Bob";    // ! Ошибка - установить нельзя
}
```

#### Модификаторы доступа

Также мы можем применять модификаторы доступа не только ко всему свойству, но и к отдельным блокам `get` и `set`:
```cs
class Person
{
    private string name = "";
    
    public string Name
    {
        get { return name; }
        private set { name = value; }
    }
}
```

Теперь закрытый блок `set` мы сможем использовать только в данном классе - в его методах, свойствах, конструкторе, но никак не в другом классе. При использовании модификаторов в свойствах следует учитывать ряд ограничений:
- Модификатор для блока set или get можно установить, если свойство имеет оба блока (и `set`, и `get`)
- Только один блок `set` или `get` может иметь модификатор доступа, но не оба сразу
#### Автоматическое свойство 

**Автоматические свойства** – синтаксический сахар, который позволяет сокращенно объявлять свойства, где не нужны дополнительные условия для геттеров и сеттеров. Автосвойствам можно присвоить значения по умолчанию, они могут иметь модификаторы доступа. Также мы можем убрать блок `set` и сделать автосвойство доступным только для чтения, но стоит учитывать, что нельзя создать автоматическое свойство только для записи, как в случае со стандартными свойствами..

```cs
public string Name { get; set; }

public int Age { get; set; } = 37;

public string Name { private set; get;}

public string Name { get; } = "Tom";
```

На самом деле тут также создаются поля для свойств, только их создает не программист в коде, а компилятор автоматически генерирует при компиляции.
## Хранение в памяти

#### Карта памяти класса
![Image alt](https://github.com/TchockDonwood/ExamPapers/blob/a9eca0cb52e216eb800dfcbb9689e31c6493ab70/%D0%9F%D1%80%D0%BE%D0%B3%D0%B0/7.png))
#### Карта памяти динамических и статических полей
Статические поля класса хранятся в куче в специальной области памяти и инициализируются до начала выполнения программы. Динамические поля хранятся в куче и инициализируются при объявлении объекта.
![Image alt](https://github.com/TchockDonwood/ExamPapers/blob/a9eca0cb52e216eb800dfcbb9689e31c6493ab70/%D0%9F%D1%80%D0%BE%D0%B3%D0%B0/9.png)
#### Карта памяти динамических и статических методов
Динамический метод не хранится со всеми объектами, и его код не копируется в каждый объект. Методы классов хранятся в отдельно выделенной области памяти, предназначенной для хранения IL-кода[^1].
![Image alt](https://github.com/TchockDonwood/ExamPapers/blob/a9eca0cb52e216eb800dfcbb9689e31c6493ab70/%D0%9F%D1%80%D0%BE%D0%B3%D0%B0/8.png)



#разобрать 
[Про стат. и дин. методы](https://forum.ixbt.com/topic.cgi?id=26:038588)
[Про динамические методы на Хабре](https://habr.com/ru/articles/730596/)
[2 часть](https://habr.com/ru/articles/735318/)


[^1]: IL, Intermediate Language — промежуточный язык.
	Одним из составляющих звеньев платформы .NET является среда выполнения Common Language Runtime (CLR). CLR работает поверх ОС – это и есть виртуальная машина, которая обрабатывает IL-код программы. Код IL – это аналог бинарного кода для платформы Win32 или байт-кода для виртуальной машины Java. Во время запуска приложения IL-код на лету компилируется в машинный код под то «железо», на котором запущена программа.


%%[[Массив]] [[Метод]]%%
