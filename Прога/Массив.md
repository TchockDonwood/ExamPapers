**Массив** представляет набор однотипных данных. 
Объявление  и инициализация массива:
```cs
тип_переменной[] название_массива = new тип_переменной[длина_массива];
название_массива[индекс_элемента] = значение_элемента;
```
Также мы сразу можем указать значения для элементов массива:
```cs
int[] nums2 = new int[4] { 1, 2, 3, 5 };
int[] nums3 = new int[] { 1, 2, 3, 5 };
int[] nums4 = new[] { 1, 2, 3, 5 };
int[] nums5 = { 1, 2, 3, 5 };
```
Для того, чтобы узнать длину массива, используем свойство `Length`:
```cs
Console.WriteLine(nums5.Length); //output: 4
```
Метод `Copy` копирует часть одного массива в другой:
```cs
string[] people =  { "Tom", "Sam", "Bob", "Kate", "Tom", "Alice" };
 
var employees = new string[3];
 
// копируем 3 элемента из массива people c индекса 1  
// и вставляем их в массив employees начиная с индекса 0
Array.Copy(people,1, employees,0, 3);
 
foreach (var person in employees) 
    Console.Write($"{person} ");
// Sam Bob Kate
```
##  Массивы и foreach

Для обращения к каждому _**значению**_ массива можно воспользоваться оператором `foreach`, о котором подробнее говорилось в этой [заметке](Циклы#^2467d3).
## Многомерные массивы

### Двумерный массив

**Двумерный массив** – это матрица однотипных данных.

Объявление и инициализация:
```cs
тип_переменной[,] название_массива = new тип_переменной[кол-во_строк, кол-во_столбцов];
название_массива[индекс_строки, индекс_столбца] = значение_элемента;
```
Короткая форма записи:
```cs
int[,] myArray = new int[3, 5]
{
	{00, 01, 02, 03, 04},
	{10, 11, 12, 13, 14},	
	{20, 21, 22, 23, 24}
};
```
Мы можем узнать кол-во строк и столбцов, используя метод `GetLength()`:
```cs
Console.WriteLine(myArray.GetLength(0)); //output: 3
Console.WriteLine(myArray.GetLength(1)); //output: 5
```
Свойство `Length` выведет количество всех элементов массива:
```cs
Console.WriteLine(myArray.Length); //output: 15
```
Свойство `Rank` выведет ранг (размерность) матрицы:
```cs
Console.WriteLine(myArray.Rank); //output: 2
```
#### Вывод двумерного массива

При выводе двумерного массива не стоит использовать оператор `foreach`, т.к. он выведет все данные в одной строке. Для данной задачи лучше использовать вложенные циклы:
```cs
for (int i = 0; i < myArray.GetLength(0); i++)
{
	for (int j = 0; j < myArray.GetLength(1); j++)
	{
		Console.Write(myArray[i, j] + "\t");
	}
	Console.WriteLine();
}
/* output:
0     1     2     3     4
10    11    12    13    14
20    21    22    23    24
*/
```
### Зубчатый (ступенчатый) массив или массив массивов

**Зубчатый (ступенчатый) массив** – это *одномерный* массив, который содержит в себе другие массивы.

Объявление и инициализация:
```cs
тип_переменной[][] название_массива = new тип_переменной[кол-во_элементов][];
название_массива[индекс_вложенного_массива] = new тип_переменной[длинна_массива];
```
Короткая форма записи:
```cs
int[][] myArray = new int[3][]
{
	new int[2] { 11, 12 }, 
    new int[3] { 21, 22, 23 }, 
    new int[5] { 31, 32, 33, 34, 35 } 
};
```
Свойство `Length` выведет количество всех элементов массива:
```cs
Console.WriteLine(myArray.Length); //output: 3
```
Свойство `Rank` выведет ранг (размерность) матрицы:
```cs
Console.WriteLine(myArray.Rank); //output: 1
```
#### Вывод зубчатого массива

Чтобы вывести зубчатый массив, аналогично выводу двумерного массива используем вложенные циклы:
```cs
for (int i = 0; i < myArray.Length; i++)
{
	for (int j = 0; j < myArray[i].Length; j++)
	{
		Console.Write(myArray[i][j] + "\t");
	}
	Console.WriteLine();
}
/* output:
11    12
21    22    23 
31    32    33    34    35
*/
```
Еще примеры:
```cs
int[][][] myArray = new int[2][][]
{
	new int[2][] 
	{ 
		new int[2] {11, 12},
		new int[5] {21, 22, 23, 24, 25}
	}, 
    new int[3][] 
	{ 
		new int[2] {11, 12},
		new int[5] {21, 22, 23, 24, 25},
		new int[3] {31, 32, 33}
	}
};
for (int i = 0; i < myArray.Length; i++)
{
	for (int j = 0; j < myArray[i].Length; j++)
	{
		for (int k = 0; k < myArray[i][j].Length; k++)
		{
			Console.Write(myArray[i][j][k] + "\t");
		}
		Console.WriteLine();
	}
	Console.WriteLine();
}
/* output:
11      12
21      22      23      24      25

11      12
21      22      23      24      25
31      32      33
*/
```

```cs
int[][] myArray = new int[2][,]
{
	new int[3, 5]
	{
		{00, 01, 02, 03, 04},
		{10, 11, 12, 13, 14},	
		{20, 21, 22, 23, 24}
	},
	new int[2, 2]
	{
		{00, 01},
		{10, 11}
	}
};
for (int i = 0; i < myArray.Length; i++)
{
	for (int j = 0; j < myArray[i].GetLength(0); j++)
	{
		for (int k = 0; k < myArray[i].GetLength(1); k++)
		{
			Console.Write(myArray[i][j,k] + "\t");
		}
		Console.WriteLine();
	}
	Console.WriteLine();
}
/* output:
0       1       2       3       4
10      11      12      13      14
20      21      22      23      24

0       1
10      11
*/
```

## Хранение массивов в памяти

Массив - [[Типы данных#Отличия ссылочных и значимых типов|ссылочный тип]], который хранит в стеке (*stack*) ссылку на значения, которые находятся в куче (*heap*). 

Следует понимать, что если массив содержит данные *ссылочного типа*, например строки, то этот массив хранит в куче ссылки на строки, которые в свою очередь хранят в куче ссылки на значения (карты памяти для наглядности расположены ниже).

*Двумерный массив* хранит ссылки на элементы таблицы, и в памяти они хранятся подряд.
```cs
int[,] myArray = new int[2, 3]
{
	{10, 15, 5},
	{33, 0, 11}
};

foreach (var e in myArray)
	Console.WriteLine(e);  //output: 1015533011 <- так они хранятся в памяти
```
*Ступенчатый массив* хранит ссылки на массивы, которые в свою очередь хранят ссылки на значения либо ссылки и т.д. Важно знать о том, что каждый массив в массиве массивов нужно *отдельно инициализировать*, а также он может быть *любой длины*.

Когда на данные в куче не указывает ни одна ссылка, они становятся неактуальными, и фреймворк .NET запускает сборщик мусора (не в real-time), который освобождает память в куче.

Карты памяти:
![[Pasted image 20250111233010.png]]
![[Pasted image 20250111233027.png]]